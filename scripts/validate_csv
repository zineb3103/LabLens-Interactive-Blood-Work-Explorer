import pandas as pd
from dateutil import parser
import sys
import os
from pathlib import Path

# Resolve paths relative to the backend directory (parent of this scripts folder)
BACKEND_DIR = Path(__file__).resolve().parents[1]
DEFAULT_CSV = BACKEND_DIR / "data" / "raw" / "synthetic_bloodwork.csv"
DEFAULT_OUT = BACKEND_DIR / "data" / "processed" / "cleaned.parquet"

CSV_PATH = sys.argv[1] if len(sys.argv) > 1 else str(DEFAULT_CSV)
OUT_PATH = str(DEFAULT_OUT)

EXPECTED_COLS = ["numorden", "sexo", "edad", "nombre", "textores", "nombre2", "Date"]

# === FONCTIONS ===
def try_parse_date(x):
    """Tente de parser une date au format jour/mois/ann√©e."""
    try:
        return pd.to_datetime(x, dayfirst=True, errors='coerce')
    except Exception:
        return pd.NaT


def detect_numeric(x):
    """Retourne True si la valeur est num√©rique, False sinon."""
    try:
        float(x)
        return True
    except Exception:
        return False


# === MAIN ===
def main():
    print(f"üìÇ Lecture du fichier CSV : {CSV_PATH}")

    # Charger le CSV avec encodage tol√©rant (essai UTF-8 puis fallback Windows/Latin-1)
    encodings_to_try = [
        ("utf-8", {}),
        ("utf-8-sig", {}),
        ("latin1", {}),
        ("cp1252", {}),
        ("latin1", {"errors": "replace"}),
    ]
    last_err = None
    for enc, extra_kwargs in encodings_to_try:
        try:
            df = pd.read_csv(CSV_PATH, dtype=str, encoding=enc, sep=",", **extra_kwargs)
            print(f"‚úÖ Encodage d√©tect√©/accept√© : {enc}{' (avec errors=replace)' if extra_kwargs.get('errors') == 'replace' else ''}")
            break
        except UnicodeDecodeError as e:
            last_err = e
            continue
    else:
        raise SystemExit(f"‚ùå √âchec de lecture avec encodages essay√©s. Derni√®re erreur: {last_err}")

    # Nettoyer les noms de colonnes
    df.columns = df.columns.str.strip()

    print("üîç Colonnes trouv√©es :", list(df.columns))

    # V√©rifier les colonnes manquantes
    missing_cols = [c for c in EXPECTED_COLS if c not in df.columns]
    if missing_cols:
        raise SystemExit(f"‚ùå Erreur : colonnes manquantes : {missing_cols}")

    # V√©rifier si les colonnes sont dans le bon ordre
    if list(df.columns) != EXPECTED_COLS:
        print("‚ö†Ô∏è  Colonnes pr√©sentes mais ordre diff√©rent. R√©organisation automatique.")
        df = df[EXPECTED_COLS].copy()

    # Convertir 'edad' en entier (nullable)
    df["edad_orig"] = df["edad"]
    df["edad"] = pd.to_numeric(df["edad"], errors="coerce").astype("Int64")

    # Convertir 'Date' en datetime
    df["Date_orig"] = df["Date"]
    df["Date"] = df["Date"].apply(try_parse_date)
    n_bad_dates = df["Date"].isna().sum()
    if n_bad_dates:
        print(f"‚ö†Ô∏è  {n_bad_dates} dates invalides d√©tect√©es (voir 'Date_orig').")
    df = df.dropna(subset=["Date"])

    # Normaliser 'sexo'
    df["sexo"] = df["sexo"].str.strip().str.upper().replace({
        "MASC": "M", "FEM": "F", "F√âMININ": "F", "MASCULIN": "M"
    })

    # D√©tecter les valeurs num√©riques dans 'textores'
    df["textores_is_numeric"] = df["textores"].apply(detect_numeric)

    # === STATISTIQUES RAPIDES ===
    print("\nüìä Statistiques rapides :")
    print("Total lignes :", len(df))
    print("Valeurs manquantes par colonne :")
    print(df[EXPECTED_COLS].isna().sum())

    # === SAUVEGARDE ===
    os.makedirs(os.path.dirname(OUT_PATH), exist_ok=True)
    df.to_parquet(OUT_PATH, index=False)
    print(f"\n‚úÖ Fichier nettoy√© sauvegard√© avec succ√®s ‚Üí {OUT_PATH}")


# === POINT D‚ÄôENTR√âE ===
if __name__ == "__main__":
    main()
